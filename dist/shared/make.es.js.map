{"version":3,"file":"make.es.js","sources":["../../src/libs/namedItemSource/format/core/namedItem/namedItem.ts","../../src/libs/namedItemSource/format/core/rule/core/compile.ts","../../src/libs/namedItemSource/format/core/rule/getPlaceHolders.ts","../../src/libs/namedItemSource/format/core/rule/rule.ts","../../src/libs/namedItemSource/format/core/rule/constants.ts","../../src/libs/namedItemSource/format/applyFormat.ts","../../src/libs/utils/types/audioFileParams/make.ts"],"sourcesContent":["import type { Data_NamedItem } from \"./types\";\r\n\r\nexport const findItemById = <T extends Data_NamedItem>(\r\n  dataId: number,\r\n  list: ReadonlyArray<T>\r\n): T | undefined => {\r\n  const item: T = list[dataId];\r\n  if (item) {\r\n    if (item.id === dataId) {\r\n      return item;\r\n    }\r\n  }\r\n\r\n  return list.find((i) => i.id === dataId);\r\n};\r\n\r\nexport const getItemName = (\r\n  list: ReadonlyArray<Data_NamedItem>,\r\n  dataId: number\r\n): string => {\r\n  const item = findItemById(dataId, list);\r\n  return item ? item.name : `?data[${dataId}]`;\r\n};\r\n","import type { PickByTypeKeys } from \"@RpgTypes/templates\";\r\nimport type { FormatArrayIndexCompiled } from \"./array\";\r\nimport type {\r\n  FormatArrayInput,\r\n  FormatPlaceholder,\r\n  FormatProperties,\r\n  FormatPropertiesCompiled,\r\n} from \"./direct\";\r\nimport type { SourceIdentifier } from \"./sourceIdentifier\";\r\n\r\nexport const compileFormatPropeties = <T>(\r\n  props: FormatProperties<T>\r\n): FormatPropertiesCompiled<T> => ({\r\n  numbers: props.numbers ? compilePlaceholders(props.numbers) : [],\r\n  strings: props.strings ? compilePlaceholders(props.strings) : [],\r\n});\r\n\r\nconst compilePlaceholders = <T, V extends number | string>(\r\n  keys: ReadonlyArray<PickByTypeKeys<T, V>>\r\n): FormatPlaceholder<T, V>[] => {\r\n  return keys.map((key) => ({\r\n    dataKey: key,\r\n    placeHolder: `{${key}}`,\r\n  }));\r\n};\r\n\r\nexport const compileArrayPlaceholder = <T, Source extends string | number>(\r\n  input: FormatArrayInput<T, Source>\r\n): FormatArrayIndexCompiled<T, Source> => {\r\n  return {\r\n    dataKey: input.dataIdKey,\r\n    placeHolder: `{${input.dataIdKey}}`,\r\n    sourceId: input.sourceId,\r\n  };\r\n};\r\n\r\nexport const compileArrayPlaceholderEX = <T>(\r\n  input: FormatArrayInput<T, SourceIdentifier>\r\n): FormatArrayIndexCompiled<T, SourceIdentifier> => {\r\n  return {\r\n    dataKey: input.dataIdKey,\r\n    placeHolder: `{${input.dataIdKey}}`,\r\n    sourceId: {\r\n      author: input.sourceId.author,\r\n      kind: input.sourceId.kind,\r\n      module: input.sourceId.module,\r\n    },\r\n  };\r\n};\r\n","import type { FormatItemMapper, FormatRule } from \"./core\";\r\n\r\nexport const getDataKeysFromFormatRule = <T>(\r\n  rule: FormatRule<T>\r\n): Set<string & keyof T> => {\r\n  return new Set<string & keyof T>([\r\n    ...(rule.placeHolder?.numbers ?? []),\r\n    ...(rule.placeHolder?.strings ?? []),\r\n    ...(rule.arrayIndex?.map((a) => a.dataIdKey) ?? []),\r\n  ]);\r\n};\r\n\r\nexport const getPlaceHolderKeys = <T>(rule: FormatRule<T>): Set<string> => {\r\n  return new Set<string>([\r\n    ...(rule.placeHolder?.numbers ?? []),\r\n    ...(rule.itemMapper ? [rule.itemMapper.placeHolder] : []),\r\n    ...(rule.itemMappers?.map((mapper) => mapper.placeHolder) ?? []),\r\n    ...(rule.placeHolder?.strings ?? []),\r\n    ...(rule.arrayIndex?.map((a) => a.dataIdKey) ?? []),\r\n  ]);\r\n};\r\n\r\nexport const getItemMappersFromRule = <T>(\r\n  rule: FormatRule<T>\r\n): ReadonlyArray<FormatItemMapper<T>> => {\r\n  const list = rule.itemMappers ?? [];\r\n  return rule.itemMapper ? [...list, rule.itemMapper] : [...list];\r\n};\r\n","import {\r\n  FORMAT_PLACEHOLDER_KEY,\r\n  DEFAULT_LABEL,\r\n  DEFAULT_TEXT,\r\n} from \"./constants\";\r\nimport type {\r\n  FormatItemMapper,\r\n  FormatItemMapperCompiled,\r\n  FormatPlaceholder,\r\n  FormatRule,\r\n  FormatRuleCompiled,\r\n} from \"./core\";\r\nimport { compileArrayPlaceholderEX, compileFormatPropeties } from \"./core\";\r\nimport {\r\n  getDataKeysFromFormatRule,\r\n  getItemMappersFromRule,\r\n} from \"./getPlaceHolders\";\r\n\r\nexport const compileFormatRule = <T>(\r\n  rule: FormatRule<T>,\r\n  extraItems: ReadonlyArray<FormatItemMapper<T>> = []\r\n): FormatRuleCompiled<T> => ({\r\n  itemMappers: [...getItemMappersFromRule(rule), ...extraItems].map(\r\n    compileItemMapper\r\n  ),\r\n  fallbackFormat: {\r\n    text: generateFallbackFormatText(rule),\r\n    label: generateFallbackLabel(rule),\r\n  },\r\n  properties: compileFormatPropeties(rule.placeHolder ?? {}),\r\n  arrayIndex: rule.arrayIndex\r\n    ? rule.arrayIndex.map(compileArrayPlaceholderEX)\r\n    : [],\r\n});\r\n\r\nconst compileItemMapper = <T>(\r\n  itemMappers: FormatItemMapper<T>\r\n): FormatItemMapperCompiled<T> => {\r\n  return {\r\n    placeHolder: `{${itemMappers.placeHolder}}`,\r\n    kindKey: itemMappers.kindKey,\r\n    dataIdKey: itemMappers.dataIdKey,\r\n  };\r\n};\r\n\r\nconst generateFallbackFormatText = <T>(rule: FormatRule<T>): string => {\r\n  if (rule.fallbackFormat) {\r\n    if (rule.fallbackFormat.text !== undefined) {\r\n      return rule.fallbackFormat.text;\r\n    }\r\n  }\r\n  const set: ReadonlySet<string & keyof T> = getDataKeysFromFormatRule(rule);\r\n  if (set.size === 0) {\r\n    return DEFAULT_TEXT;\r\n  }\r\n\r\n  return Array.from(set)\r\n    .map((item) => `${item}:{${item}}`)\r\n    .join(\", \");\r\n};\r\n\r\nconst generateFallbackLabel = <T>(rule: FormatRule<T>): string => {\r\n  if (rule.fallbackFormat?.label !== undefined) {\r\n    return rule.fallbackFormat.label;\r\n  }\r\n  return DEFAULT_LABEL;\r\n};\r\n\r\nexport const resolveUnknownLabel = <T>(\r\n  rule: FormatRuleCompiled<T>,\r\n  key: string\r\n): string => {\r\n  return rule.fallbackFormat.label.replace(FORMAT_PLACEHOLDER_KEY, key);\r\n};\r\n\r\nexport const applyPlaceholdersToText = <Schema, Data extends Schema>(\r\n  baseText: string,\r\n  data: Data,\r\n  rule: FormatRuleCompiled<Schema>\r\n): string => {\r\n  const numText: string = rule.properties.numbers.reduce(\r\n    (text, field) => replacePlaceholder(text, data, field),\r\n    baseText\r\n  );\r\n  return rule.properties.strings.reduce(\r\n    (text, field) => replacePlaceholder(text, data, field),\r\n    numText\r\n  );\r\n};\r\n\r\nconst replacePlaceholder = <\r\n  Schema,\r\n  Data extends Schema,\r\n  Value extends number | string\r\n>(\r\n  baseText: string,\r\n  data: Data,\r\n  field: FormatPlaceholder<Schema, Value>\r\n): string => {\r\n  const value = data[field.dataKey satisfies keyof Data];\r\n  if (value === undefined || value === null) {\r\n    return baseText;\r\n  }\r\n  return baseText.replaceAll(field.placeHolder, String(value));\r\n};\r\n","export const FORMAT_PLACEHOLDER_KEY = \"{key}\";\r\nexport const DEFAULT_LABEL = \"unknown key:{key}\";\r\nexport const DEFAULT_TEXT = \"value not found\";\r\n","import type { CompiledFormatBundle } from \"./bundle\";\r\nimport type {\r\n  Data_NamedItem,\r\n  FormatCompiled,\r\n  FormatErrorLabels,\r\n  FormatLabelResolved,\r\n  FormatResult,\r\n  FormatRule,\r\n  FormatRuleCompiled,\r\n  NamedItemSource,\r\n} from \"./core\";\r\nimport {\r\n  compileFormatRule,\r\n  applyPlaceholdersToText,\r\n  getItemName,\r\n  resolveUnknownLabel,\r\n} from \"./core\";\r\nimport type { FormatLookupKeys } from \"./core/accessor\";\r\nimport { collectFormatErrors } from \"./core/detectErrors\";\r\nimport { mergeItemsSource } from \"./mergeItemsSource\";\r\n\r\nexport const compileFormatBundle = <T extends object, KindKey>(\r\n  rule: FormatRule<T>,\r\n  formatList: ReadonlyArray<FormatLabelResolved<KindKey>>,\r\n  namedItemSources: ReadonlyArray<NamedItemSource>,\r\n  errorTexts: FormatErrorLabels\r\n): CompiledFormatBundle<T, KindKey> => {\r\n  return {\r\n    soruceMap: mergeItemsSource(formatList, namedItemSources),\r\n    errors: collectFormatErrors(formatList, rule, errorTexts),\r\n    compiledRule: compileFormatRule(rule),\r\n  };\r\n};\r\n\r\nexport const isValidFormatBundle = <T extends object, KindKey>(\r\n  bundle: CompiledFormatBundle<T, KindKey>\r\n): boolean => {\r\n  return bundle.errors.length === 0;\r\n};\r\n\r\nexport const formatWithCompiledBundle = <T extends object, KindKey>(\r\n  data: T,\r\n  bundle: CompiledFormatBundle<T, KindKey>,\r\n  lookup: FormatLookupKeys<T, KindKey>\r\n): FormatResult => {\r\n  const key: KindKey = lookup.extractMapKey(data);\r\n  const entry = bundle.soruceMap.get(key);\r\n  return entry\r\n    ? formatTextForMatchedEntry(data, bundle.compiledRule, entry, (d) =>\r\n        lookup.extractDataId(d)\r\n      )\r\n    : formatTextForFallback(data, bundle.compiledRule, key, lookup);\r\n};\r\n\r\nconst formatTextForMatchedEntry = <T extends object>(\r\n  data: T,\r\n  rule: FormatRuleCompiled<T>,\r\n  format: FormatCompiled,\r\n  getDataId: (data: T) => number\r\n): FormatResult => {\r\n  return {\r\n    label: format.label,\r\n    text: applyFormatRule(\r\n      data,\r\n      format.data,\r\n      rule,\r\n      format.patternCompiled,\r\n      getDataId\r\n    ),\r\n  };\r\n};\r\n\r\nconst formatTextForFallback = <T extends object, KindKey>(\r\n  data: T,\r\n  rule: FormatRuleCompiled<T>,\r\n  key: KindKey,\r\n  lookup: FormatLookupKeys<T, KindKey>\r\n): FormatResult => {\r\n  return {\r\n    label: resolveUnknownLabel(rule, lookup.unknownKey(key)),\r\n    text: applyFormatRule(\r\n      data,\r\n      undefined,\r\n      rule,\r\n      rule.fallbackFormat.text,\r\n      (d) => lookup.extractDataId(d)\r\n    ),\r\n  };\r\n};\r\n\r\nexport const applyFormatRule = <Schema, Data extends Schema>(\r\n  data: Data,\r\n  list: ReadonlyArray<Data_NamedItem> | undefined,\r\n  rule: FormatRuleCompiled<Schema>,\r\n  format: string,\r\n  getDataId: (data: Data) => number\r\n): string => {\r\n  const text: string = applyPlaceholdersToText(format, data, rule);\r\n  return list ? formatWithItemName(text, data, rule, list, getDataId) : text;\r\n};\r\n\r\nconst formatWithItemName = <Schema, Data extends Schema>(\r\n  text: string,\r\n  data: Data,\r\n  rule: FormatRuleCompiled<Schema>,\r\n  list: ReadonlyArray<Data_NamedItem>,\r\n  getDataId: (data: Data) => number\r\n): string => {\r\n  const itemName: string = getItemName(list, getDataId(data));\r\n  return rule.itemMappers.reduce((currentText, itemMapper) => {\r\n    return currentText.replaceAll(itemMapper.placeHolder, itemName);\r\n  }, text);\r\n};\r\n","import type { AudioFileParams } from \"./audioFileParams\";\r\n\r\nexport const makeAudioFileParams = (\r\n  audioFileParams: Partial<AudioFileParams> = {}\r\n): AudioFileParams => {\r\n  return {\r\n    name: audioFileParams.name ?? \"\",\r\n    volume: audioFileParams.volume ?? 100,\r\n    pitch: audioFileParams.pitch ?? 100,\r\n    pan: audioFileParams.pan ?? 0,\r\n  };\r\n};\r\n"],"names":["compilePlaceholders","keys","map","key","dataKey","placeHolder","compileArrayPlaceholderEX","input","dataIdKey","sourceId","author","kind","module","getPlaceHolderKeys","rule","Set","numbers","itemMapper","itemMappers","mapper","strings","arrayIndex","a","getItemMappersFromRule","list","compileFormatRule","extraItems","compileItemMapper","fallbackFormat","text","generateFallbackFormatText","label","generateFallbackLabel","properties","props","kindKey","set","size","Array","from","item","join","replacePlaceholder","baseText","data","field","value","replaceAll","String","applyFormatRule","format","getDataId","numText","reduce","applyPlaceholdersToText","formatWithItemName","itemName","dataId","id","find","i","name","currentText","makeAudioFileParams","audioFileParams","volume","pitch","pan"],"mappings":"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"}