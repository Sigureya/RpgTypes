{"version":3,"file":"mergeItemsSource.cjs.js","sources":["../../src/libs/namedItemSource/format/core/rule/core/sourceIdentifier/sourceId.ts","../../src/libs/namedItemSource/format/mergeItemsSource.ts"],"sourcesContent":["import type { SourceIdentifier } from \"./types\";\r\n\r\nexport const joinSoruceId = (source: SourceIdentifier): string => {\r\n  return `${source.author}.${source.module}.${source.kind}`;\r\n};\r\n","import type {\r\n  Data_NamedItem,\r\n  FormatCompiled,\r\n  FormatLabelResolved,\r\n  NamedItemSource,\r\n  SourceIdentifier,\r\n} from \"./core\";\r\nimport { joinSoruceId } from \"./core\";\r\n\r\nexport const mergeItemsSource = <Key>(\r\n  formatList: ReadonlyArray<FormatLabelResolved<Key>>,\r\n  namedItemSources: ReadonlyArray<NamedItemSource>\r\n): Map<Key, FormatCompiled> => {\r\n  const sourceMap = mappingNamedItems(namedItemSources);\r\n  return formatList.reduce<Map<Key, FormatCompiled>>((acc, label) => {\r\n    const entry = buildFinalFormatEntry(label, sourceMap);\r\n    acc.set(label.kindId, entry);\r\n    return acc;\r\n  }, new Map());\r\n};\r\n\r\nconst buildFinalFormatEntry = <T>(\r\n  format: FormatLabelResolved<T>,\r\n  sourceMap: ReadonlyMap<string, NamedItemSource>\r\n): FormatCompiled => {\r\n  const source = resolveDataSource(format.dataSource, sourceMap);\r\n  return {\r\n    patternCompiled: format.pattern,\r\n    label: format.label,\r\n    data: source ? source.items : undefined,\r\n  };\r\n};\r\n\r\nconst resolveDataSource = (\r\n  source: SourceIdentifier | undefined,\r\n  sourceMap: ReadonlyMap<string, NamedItemSource>\r\n): NamedItemSource | undefined => {\r\n  if (!source) {\r\n    return undefined;\r\n  }\r\n  return sourceMap.get(joinSoruceId(source));\r\n};\r\n\r\nconst mappingNamedItems = (\r\n  list: ReadonlyArray<NamedItemSource>\r\n): Map<string, NamedItemSource> => {\r\n  return list.reduce<Map<string, NamedItemSource>>((map, item) => {\r\n    const newItem: NamedItemSource = {\r\n      items: cloneItems(item.items), // 余計な情報の削除を兼ねてコピー\r\n      source: item.source,\r\n      label: item.label,\r\n    };\r\n    map.set(joinSoruceId(item.source), newItem);\r\n    return map;\r\n  }, new Map());\r\n};\r\n\r\nconst cloneItems = (list: ReadonlyArray<Data_NamedItem>): Data_NamedItem[] => {\r\n  return list.map<Data_NamedItem>((item) => ({ id: item.id, name: item.name }));\r\n};\r\n"],"names":["joinSoruceId","source","author","module","kind","buildFinalFormatEntry","format","sourceMap","resolveDataSource","dataSource","patternCompiled","pattern","label","data","items","get","mappingNamedItems","list","reduce","map","item","newItem","cloneItems","set","Map","id","name","formatList","namedItemSources","acc","entry","kindId"],"mappings":";AAEa,MAAAA,IAAgBC,CAAAA,OACpB,GAAGA,GAAOC,MAAUD,IAAAA,GAAOE,MAAUF,IAAAA,GAAOG,QCkB/CC,IAAwB,CAC5BC,IACAC,OAAAA;AAEA,QAAMN,KAASO,EAAkBF,GAAOG,YAAYF;AAC7C,SAAA,EACLG,iBAAiBJ,GAAOK,SACxBC,OAAON,GAAOM,OACdC,MAAMZ,KAASA,GAAOa,QAAAA,OAIpBN;AAAAA,GAAAA,IAAoB,CACxBP,IACAM,OAAAA;AAEA,MAAKN,GAGL,QAAOM,GAAUQ,IAAIf,EAAaC,EAAAA,CAAAA;AAAAA,GAG9Be,IACJC,CAAAA,OAEOA,GAAKC,OAAqC,CAACC,IAAKC;AACrD,QAAMC,KAA2B,EAC/BP,OAAOQ,EAAWF,GAAKN,KACvBb,GAAAA,QAAQmB,GAAKnB,QACbW,OAAOQ,GAAKR,MAGP;AAAA,SADPO,GAAII,IAAIvB,EAAaoB,GAAKnB,MAASoB,GAAAA,EAAAA,GAC5BF;GACF,oBAAAK,KAAAA,GAGHF,IAAcL,CAAAA,OACXA,GAAKE,IAAqBC,CAAAA,QAAU;AAAA,EAAEK,IAAIL,GAAKK;AAAAA,EAAIC,MAAMN,GAAKM;AAAAA,EAAAA;2BAjDvC,CAC9BC,IACAC,OAEM;AAAA,QAAArB,KAAYS,EAAkBY,EACpC;AAAA,SAAOD,GAAWT,OAAiC,CAACW,IAAKjB,OACjD;AAAA,UAAAkB,KAAQzB,EAAsBO,IAAOL,EAAAA;AAEpC,WADHsB,GAAAN,IAAIX,GAAMmB,QAAQD,EAAAA,GACfD;AAAAA,KACF,oBAAAL,KAAAA;AAAAA;"}