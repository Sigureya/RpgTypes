{"version":3,"file":"make.cjs.js","sources":["../../src/libs/namedItemSource/format/core/namedItem/namedItem.ts","../../src/libs/namedItemSource/format/core/rule/core/compile.ts","../../src/libs/namedItemSource/format/core/rule/getPlaceHolders.ts","../../src/libs/namedItemSource/format/core/rule/rule.ts","../../src/libs/namedItemSource/format/core/rule/constants.ts","../../src/libs/namedItemSource/format/applyFormat.ts","../../src/libs/utils/types/audioFileParams/make.ts"],"sourcesContent":["import type { Data_NamedItem } from \"./types\";\r\n\r\nexport const findItemById = <T extends Data_NamedItem>(\r\n  dataId: number,\r\n  list: ReadonlyArray<T>\r\n): T | undefined => {\r\n  const item: T = list[dataId];\r\n  if (item) {\r\n    if (item.id === dataId) {\r\n      return item;\r\n    }\r\n  }\r\n\r\n  return list.find((i) => i.id === dataId);\r\n};\r\n\r\nexport const getItemName = (\r\n  list: ReadonlyArray<Data_NamedItem>,\r\n  dataId: number\r\n): string => {\r\n  const item = findItemById(dataId, list);\r\n  return item ? item.name : `?data[${dataId}]`;\r\n};\r\n","import type { PickByTypeKeys } from \"@RpgTypes/templates\";\r\nimport type { FormatArrayIndexCompiled } from \"./array\";\r\nimport type {\r\n  FormatArrayInput,\r\n  FormatPlaceholder,\r\n  FormatProperties,\r\n  FormatPropertiesCompiled,\r\n} from \"./direct\";\r\nimport type { SourceIdentifier } from \"./sourceIdentifier\";\r\n\r\nexport const compileFormatPropeties = <T>(\r\n  props: FormatProperties<T>\r\n): FormatPropertiesCompiled<T> => ({\r\n  numbers: props.numbers ? compilePlaceholders(props.numbers) : [],\r\n  strings: props.strings ? compilePlaceholders(props.strings) : [],\r\n});\r\n\r\nconst compilePlaceholders = <T, V extends number | string>(\r\n  keys: ReadonlyArray<PickByTypeKeys<T, V>>\r\n): FormatPlaceholder<T, V>[] => {\r\n  return keys.map((key) => ({\r\n    dataKey: key,\r\n    placeHolder: `{${key}}`,\r\n  }));\r\n};\r\n\r\nexport const compileArrayPlaceholder = <T, Source extends string | number>(\r\n  input: FormatArrayInput<T, Source>\r\n): FormatArrayIndexCompiled<T, Source> => {\r\n  return {\r\n    dataKey: input.dataIdKey,\r\n    placeHolder: `{${input.dataIdKey}}`,\r\n    sourceId: input.sourceId,\r\n  };\r\n};\r\n\r\nexport const compileArrayPlaceholderEX = <T>(\r\n  input: FormatArrayInput<T, SourceIdentifier>\r\n): FormatArrayIndexCompiled<T, SourceIdentifier> => {\r\n  return {\r\n    dataKey: input.dataIdKey,\r\n    placeHolder: `{${input.dataIdKey}}`,\r\n    sourceId: {\r\n      author: input.sourceId.author,\r\n      kind: input.sourceId.kind,\r\n      module: input.sourceId.module,\r\n    },\r\n  };\r\n};\r\n","import type { FormatItemMapper, FormatRule } from \"./core\";\r\n\r\nexport const getDataKeysFromFormatRule = <T>(\r\n  rule: FormatRule<T>\r\n): Set<string & keyof T> => {\r\n  return new Set<string & keyof T>([\r\n    ...(rule.placeHolder?.numbers ?? []),\r\n    ...(rule.placeHolder?.strings ?? []),\r\n    ...(rule.arrayIndex?.map((a) => a.dataIdKey) ?? []),\r\n  ]);\r\n};\r\n\r\nexport const getPlaceHolderKeys = <T>(rule: FormatRule<T>): Set<string> => {\r\n  return new Set<string>([\r\n    ...(rule.placeHolder?.numbers ?? []),\r\n    ...(rule.itemMapper ? [rule.itemMapper.placeHolder] : []),\r\n    ...(rule.itemMappers?.map((mapper) => mapper.placeHolder) ?? []),\r\n    ...(rule.placeHolder?.strings ?? []),\r\n    ...(rule.arrayIndex?.map((a) => a.dataIdKey) ?? []),\r\n  ]);\r\n};\r\n\r\nexport const getItemMappersFromRule = <T>(\r\n  rule: FormatRule<T>\r\n): ReadonlyArray<FormatItemMapper<T>> => {\r\n  const list = rule.itemMappers ?? [];\r\n  return rule.itemMapper ? [...list, rule.itemMapper] : [...list];\r\n};\r\n","import {\r\n  FORMAT_PLACEHOLDER_KEY,\r\n  DEFAULT_LABEL,\r\n  DEFAULT_TEXT,\r\n} from \"./constants\";\r\nimport type {\r\n  FormatItemMapper,\r\n  FormatItemMapperCompiled,\r\n  FormatPlaceholder,\r\n  FormatRule,\r\n  FormatRuleCompiled,\r\n} from \"./core\";\r\nimport { compileArrayPlaceholderEX, compileFormatPropeties } from \"./core\";\r\nimport {\r\n  getDataKeysFromFormatRule,\r\n  getItemMappersFromRule,\r\n} from \"./getPlaceHolders\";\r\n\r\nexport const compileFormatRule = <T>(\r\n  rule: FormatRule<T>,\r\n  extraItems: ReadonlyArray<FormatItemMapper<T>> = []\r\n): FormatRuleCompiled<T> => ({\r\n  itemMappers: [...getItemMappersFromRule(rule), ...extraItems].map(\r\n    compileItemMapper\r\n  ),\r\n  fallbackFormat: {\r\n    text: generateFallbackFormatText(rule),\r\n    label: generateFallbackLabel(rule),\r\n  },\r\n  properties: compileFormatPropeties(rule.placeHolder ?? {}),\r\n  arrayIndex: rule.arrayIndex\r\n    ? rule.arrayIndex.map(compileArrayPlaceholderEX)\r\n    : [],\r\n});\r\n\r\nconst compileItemMapper = <T>(\r\n  itemMappers: FormatItemMapper<T>\r\n): FormatItemMapperCompiled<T> => {\r\n  return {\r\n    placeHolder: `{${itemMappers.placeHolder}}`,\r\n    kindKey: itemMappers.kindKey,\r\n    dataIdKey: itemMappers.dataIdKey,\r\n  };\r\n};\r\n\r\nconst generateFallbackFormatText = <T>(rule: FormatRule<T>): string => {\r\n  if (rule.fallbackFormat) {\r\n    if (rule.fallbackFormat.text !== undefined) {\r\n      return rule.fallbackFormat.text;\r\n    }\r\n  }\r\n  const set: ReadonlySet<string & keyof T> = getDataKeysFromFormatRule(rule);\r\n  if (set.size === 0) {\r\n    return DEFAULT_TEXT;\r\n  }\r\n\r\n  return Array.from(set)\r\n    .map((item) => `${item}:{${item}}`)\r\n    .join(\", \");\r\n};\r\n\r\nconst generateFallbackLabel = <T>(rule: FormatRule<T>): string => {\r\n  if (rule.fallbackFormat?.label !== undefined) {\r\n    return rule.fallbackFormat.label;\r\n  }\r\n  return DEFAULT_LABEL;\r\n};\r\n\r\nexport const resolveUnknownLabel = <T>(\r\n  rule: FormatRuleCompiled<T>,\r\n  key: string\r\n): string => {\r\n  return rule.fallbackFormat.label.replace(FORMAT_PLACEHOLDER_KEY, key);\r\n};\r\n\r\nexport const applyPlaceholdersToText = <Schema, Data extends Schema>(\r\n  baseText: string,\r\n  data: Data,\r\n  rule: FormatRuleCompiled<Schema>\r\n): string => {\r\n  const numText: string = rule.properties.numbers.reduce(\r\n    (text, field) => replacePlaceholder(text, data, field),\r\n    baseText\r\n  );\r\n  return rule.properties.strings.reduce(\r\n    (text, field) => replacePlaceholder(text, data, field),\r\n    numText\r\n  );\r\n};\r\n\r\nconst replacePlaceholder = <\r\n  Schema,\r\n  Data extends Schema,\r\n  Value extends number | string\r\n>(\r\n  baseText: string,\r\n  data: Data,\r\n  field: FormatPlaceholder<Schema, Value>\r\n): string => {\r\n  const value = data[field.dataKey satisfies keyof Data];\r\n  if (value === undefined || value === null) {\r\n    return baseText;\r\n  }\r\n  return baseText.replaceAll(field.placeHolder, String(value));\r\n};\r\n","export const FORMAT_PLACEHOLDER_KEY = \"{key}\";\r\nexport const DEFAULT_LABEL = \"unknown key:{key}\";\r\nexport const DEFAULT_TEXT = \"value not found\";\r\n","import type { CompiledFormatBundle } from \"./bundle\";\r\nimport type {\r\n  Data_NamedItem,\r\n  FormatCompiled,\r\n  FormatErrorLabels,\r\n  FormatLabelResolved,\r\n  FormatResult,\r\n  FormatRule,\r\n  FormatRuleCompiled,\r\n  NamedItemSource,\r\n} from \"./core\";\r\nimport {\r\n  compileFormatRule,\r\n  applyPlaceholdersToText,\r\n  getItemName,\r\n  resolveUnknownLabel,\r\n} from \"./core\";\r\nimport type { FormatLookupKeys } from \"./core/accessor\";\r\nimport { collectFormatErrors } from \"./core/detectErrors\";\r\nimport { mergeItemsSource } from \"./mergeItemsSource\";\r\n\r\nexport const compileFormatBundle = <T extends object, KindKey>(\r\n  rule: FormatRule<T>,\r\n  formatList: ReadonlyArray<FormatLabelResolved<KindKey>>,\r\n  namedItemSources: ReadonlyArray<NamedItemSource>,\r\n  errorTexts: FormatErrorLabels\r\n): CompiledFormatBundle<T, KindKey> => {\r\n  return {\r\n    soruceMap: mergeItemsSource(formatList, namedItemSources),\r\n    errors: collectFormatErrors(formatList, rule, errorTexts),\r\n    compiledRule: compileFormatRule(rule),\r\n  };\r\n};\r\n\r\nexport const isValidFormatBundle = <T extends object, KindKey>(\r\n  bundle: CompiledFormatBundle<T, KindKey>\r\n): boolean => {\r\n  return bundle.errors.length === 0;\r\n};\r\n\r\nexport const formatWithCompiledBundle = <T extends object, KindKey>(\r\n  data: T,\r\n  bundle: CompiledFormatBundle<T, KindKey>,\r\n  lookup: FormatLookupKeys<T, KindKey>\r\n): FormatResult => {\r\n  const key: KindKey = lookup.extractMapKey(data);\r\n  const entry = bundle.soruceMap.get(key);\r\n  return entry\r\n    ? formatTextForMatchedEntry(data, bundle.compiledRule, entry, (d) =>\r\n        lookup.extractDataId(d)\r\n      )\r\n    : formatTextForFallback(data, bundle.compiledRule, key, lookup);\r\n};\r\n\r\nconst formatTextForMatchedEntry = <T extends object>(\r\n  data: T,\r\n  rule: FormatRuleCompiled<T>,\r\n  format: FormatCompiled,\r\n  getDataId: (data: T) => number\r\n): FormatResult => {\r\n  return {\r\n    label: format.label,\r\n    text: applyFormatRule(\r\n      data,\r\n      format.data,\r\n      rule,\r\n      format.patternCompiled,\r\n      getDataId\r\n    ),\r\n  };\r\n};\r\n\r\nconst formatTextForFallback = <T extends object, KindKey>(\r\n  data: T,\r\n  rule: FormatRuleCompiled<T>,\r\n  key: KindKey,\r\n  lookup: FormatLookupKeys<T, KindKey>\r\n): FormatResult => {\r\n  return {\r\n    label: resolveUnknownLabel(rule, lookup.unknownKey(key)),\r\n    text: applyFormatRule(\r\n      data,\r\n      undefined,\r\n      rule,\r\n      rule.fallbackFormat.text,\r\n      (d) => lookup.extractDataId(d)\r\n    ),\r\n  };\r\n};\r\n\r\nexport const applyFormatRule = <Schema, Data extends Schema>(\r\n  data: Data,\r\n  list: ReadonlyArray<Data_NamedItem> | undefined,\r\n  rule: FormatRuleCompiled<Schema>,\r\n  format: string,\r\n  getDataId: (data: Data) => number\r\n): string => {\r\n  const text: string = applyPlaceholdersToText(format, data, rule);\r\n  return list ? formatWithItemName(text, data, rule, list, getDataId) : text;\r\n};\r\n\r\nconst formatWithItemName = <Schema, Data extends Schema>(\r\n  text: string,\r\n  data: Data,\r\n  rule: FormatRuleCompiled<Schema>,\r\n  list: ReadonlyArray<Data_NamedItem>,\r\n  getDataId: (data: Data) => number\r\n): string => {\r\n  const itemName: string = getItemName(list, getDataId(data));\r\n  return rule.itemMappers.reduce((currentText, itemMapper) => {\r\n    return currentText.replaceAll(itemMapper.placeHolder, itemName);\r\n  }, text);\r\n};\r\n","import type { AudioFileParams } from \"./audioFileParams\";\r\n\r\nexport const makeAudioFileParams = (\r\n  audioFileParams: Partial<AudioFileParams> = {}\r\n): AudioFileParams => {\r\n  return {\r\n    name: audioFileParams.name ?? \"\",\r\n    volume: audioFileParams.volume ?? 100,\r\n    pitch: audioFileParams.pitch ?? 100,\r\n    pan: audioFileParams.pan ?? 0,\r\n  };\r\n};\r\n"],"names":["compilePlaceholders","keys","map","key","dataKey","placeHolder","compileArrayPlaceholderEX","input","dataIdKey","sourceId","author","kind","module","getItemMappersFromRule","rule","list","itemMappers","itemMapper","compileItemMapper","kindKey","generateFallbackFormatText","fallbackFormat","text","set","Set","numbers","strings","arrayIndex","a","size","Array","from","item","join","generateFallbackLabel","label","replacePlaceholder","baseText","data","field","value","replaceAll","String","formatWithItemName","getDataId","itemName","dataId","id","find","i","findItemById","name","reduce","currentText","format","numText","properties","applyPlaceholdersToText","extraItems","props","mapper","audioFileParams","volume","pitch","pan"],"mappings":"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"}