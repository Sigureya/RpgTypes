{"version":3,"file":"libs.es.js","sources":["../../src/libs/namedItemSource/constants.ts","../../src/libs/namedItemSource/format/core/detectErrors.ts","../../src/libs/utils/isValidNumber.ts","../../src/libs/templates/domainLabel/domainLabel.ts"],"sourcesContent":["export const AUTHOR_RMMZ = \"rmmz\" as const;\r\nexport const SRC_COLOR = \"colors\" as const;\r\n","import type {\r\n  FormatErrorLabels,\r\n  FormatLimits,\r\n  FormatErrorGroup,\r\n  FormatErrorItem,\r\n} from \"./formatErrorTypes\";\r\nimport type { FormatRule, FormatItemMapper } from \"./rule\";\r\nimport { getItemMappersFromRule, getPlaceHolderKeys } from \"./rule\";\r\nimport type { FormatInput, FormatWithSource } from \"./types\";\r\n\r\nexport const isValidFormatErrorGroup = (\r\n  formatError: FormatErrorGroup\r\n): boolean => {\r\n  return (\r\n    formatError.syntaxErrors.length === 0 &&\r\n    formatError.semanticErrors.length === 0\r\n  );\r\n};\r\n\r\nexport const collectFormatErrors = <T extends object>(\r\n  formatList: ReadonlyArray<FormatInput>,\r\n  formatRule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels,\r\n  limits: FormatLimits = {\r\n    placeHolderMaxLength: 50,\r\n    formatMaxLength: 200,\r\n  }\r\n): FormatErrorGroup[] => {\r\n  return formatList.reduce<FormatErrorGroup[]>((acc, format) => {\r\n    const errors = detectFormatErrors(format, formatRule, errorTexts, limits);\r\n    if (!isValidFormatErrorGroup(errors)) {\r\n      acc.push(errors);\r\n    }\r\n    return acc;\r\n  }, []);\r\n};\r\n\r\nexport const detectFormatErrors = <T extends object>(\r\n  format: FormatInput,\r\n  formatRule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels,\r\n  limits: FormatLimits = {\r\n    placeHolderMaxLength: 50,\r\n    formatMaxLength: 200,\r\n  }\r\n): FormatErrorGroup => {\r\n  if (format.pattern.length >= limits.formatMaxLength) {\r\n    return {\r\n      formatLabel: format.label,\r\n      syntaxErrors: [\r\n        {\r\n          message: errorTexts.formatVeryLong,\r\n          reason: format.pattern.slice(0, limits.formatMaxLength),\r\n        },\r\n      ],\r\n      semanticErrors: [],\r\n    };\r\n  }\r\n  return {\r\n    formatLabel: format.label,\r\n    semanticErrors: detectItemMapperErrors(format, formatRule, errorTexts),\r\n    syntaxErrors: detectInvalidPlaceholders(\r\n      format.pattern,\r\n      formatRule,\r\n      errorTexts,\r\n      limits.placeHolderMaxLength\r\n    ),\r\n  };\r\n};\r\n\r\nconst detectInvalidPlaceholders = <T extends object>(\r\n  format: string,\r\n  rule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels,\r\n  placeHolderMaxLength: number\r\n): FormatErrorItem[] => {\r\n  const matched = Array.from(format.matchAll(/\\{([.a-zA-Z0-9]+)\\}/g));\r\n  const placeHolderKeys: ReadonlySet<string> = getPlaceHolderKeys(rule);\r\n  return matched.reduce<FormatErrorItem[]>((acc, item) => {\r\n    const text: string = item[1];\r\n\r\n    if (text.length === 0) {\r\n      return acc;\r\n    }\r\n    if (text.length > placeHolderMaxLength) {\r\n      acc.push({\r\n        message: errorTexts.longPlaceHolder,\r\n        reason: text.slice(0, placeHolderMaxLength),\r\n      });\r\n      return acc;\r\n    }\r\n    if (!placeHolderKeys.has(text)) {\r\n      acc.push({\r\n        message: errorTexts.extraPlaceHolder,\r\n        reason: text,\r\n      });\r\n    }\r\n    return acc;\r\n  }, []);\r\n};\r\n\r\nconst detectItemMapperErrors = <T extends object>(\r\n  format: FormatWithSource,\r\n  formatRule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels\r\n): FormatErrorItem[] => {\r\n  return getItemMappersFromRule(formatRule).reduce<FormatErrorItem[]>(\r\n    (rule, item) => {\r\n      const error = checkItemMapperSourceError(format, item, errorTexts);\r\n      if (error) {\r\n        rule.push(error);\r\n      }\r\n      return rule;\r\n    },\r\n    []\r\n  );\r\n};\r\n\r\nconst checkItemMapperSourceError = <T>(\r\n  format: FormatWithSource,\r\n  rule: FormatItemMapper<T>,\r\n  errorTexts: FormatErrorLabels\r\n): FormatErrorItem | undefined => {\r\n  const includedName: boolean = format.pattern.includes(rule.placeHolder);\r\n  const hasSource: boolean = !!format.dataSource;\r\n  if (!includedName && hasSource) {\r\n    return {\r\n      message: errorTexts.missingName,\r\n      reason: rule.placeHolder,\r\n    };\r\n  }\r\n  if (includedName && !hasSource) {\r\n    return {\r\n      message: errorTexts.missingSourceId,\r\n      reason: rule.placeHolder,\r\n    };\r\n  }\r\n  return undefined;\r\n};\r\n","export const isValidNumber = (val: unknown): val is number => {\r\n  return typeof val === \"number\" && !Number.isNaN(val);\r\n};\r\n","import type { DomainName } from \"./types\";\r\n\r\nexport const domainNames = <T extends Record<string, DomainName>>(\r\n  record: T\r\n): string[] => {\r\n  return Object.entries<DomainName>(record).map(([, value]) => value.title);\r\n};\r\n"],"names":["AUTHOR_RMMZ","SRC_COLOR","detectFormatErrors","format","formatRule","errorTexts","limits","placeHolderMaxLength","formatMaxLength","pattern","length","formatLabel","label","syntaxErrors","message","formatVeryLong","reason","slice","semanticErrors","detectItemMapperErrors","detectInvalidPlaceholders","rule","matched","Array","from","matchAll","placeHolderKeys","getPlaceHolderKeys","reduce","acc","item","text","push","longPlaceHolder","has","extraPlaceHolder","getItemMappersFromRule","error","checkItemMapperSourceError","includedName","includes","placeHolder","hasSource","dataSource","missingName","missingSourceId","isValidNumber","val","Number","isNaN","domainNames","record","Object","entries","map","value","title"],"mappings":";;;AAAO,MAAMA,IAAc,QACdC,IAAY,UCoCZC,IAAqB,CAChCC,IACAC,IACAC,IACAC,KAAuB;AAAA,EACrBC,sBAAsB;AAAA,EACtBC,iBAAiB;MAGfL,GAAOM,QAAQC,UAAUJ,GAAOE,kBAC3B,EACLG,aAAaR,GAAOS,OACpBC,cAAc,CACZ,EACEC,SAAST,GAAWU,gBACpBC,QAAQb,GAAOM,QAAQQ,MAAM,GAAGX,GAAOE,eAG3CU,EAAAA,CAAAA,GAAAA,gBAAgB,CAGb,EAAA,IAAA;AAAA,EACLP,aAAaR,GAAOS;AAAAA,EACpBM,gBAAgBC,EAAuBhB,IAAQC,IAAYC,EAC3DQ;AAAAA,EAAAA,cAAcO,EACZjB,GAAOM,SACPL,IACAC,IACAC,GAAOC,oBAKPa;AAAAA,GAAAA,IAA4B,CAChCjB,IACAkB,IACAhB,IACAE,OAEA;AAAA,QAAMe,KAAUC,MAAMC,KAAKrB,GAAOsB,SAAS,sBAAA,CAAA,GACrCC,KAAuCC,EAAmBN,EAAAA;AAChE,SAAOC,GAAQM,OAA0B,CAACC,IAAKC,OAAAA;AACvC,UAAAC,KAAeD,GAAK,CAEtB;AAAA,WAAgB,MAAhBC,GAAKrB,SACAmB,KAELE,GAAKrB,SAASH,MAChBsB,GAAIG,KAAK,EACPlB,SAAST,GAAW4B,iBACpBjB,QAAQe,GAAKd,MAAM,GAAGV,EAAAA,EAAAA,CAAAA,GAEjBsB,OAEJH,GAAgBQ,IAAIH,EACvBF,KAAAA,GAAIG,KAAK;AAAA,MACPlB,SAAST,GAAW8B;AAAAA,MACpBnB,QAAQe;AAAAA,QAGLF;AAAAA,EACN,GAAA,CAAA,CAAA;AAAA,GAGCV,IAAyB,CAC7BhB,IACAC,IACAC,OAEO+B,EAAuBhC,EAAYwB,EAAAA,OACxC,CAACP,IAAMS,OAAAA;AACL,QAAMO,KAAQC,EAA2BnC,IAAQ2B,IAAMzB,EAAAA;AAIhD,SAHHgC,MACFhB,GAAKW,KAAKK,EAAAA,GAELhB;GAET,CAIEiB,CAAAA,GAAAA,IAA6B,CACjCnC,IACAkB,IACAhB,OAEA;AAAA,QAAMkC,KAAwBpC,GAAOM,QAAQ+B,SAASnB,GAAKoB,WAAAA,GACrDC,OAAuBvC,GAAOwC;AAChC,SAAA,CAACJ,MAAgBG,KACZ,EACL5B,SAAST,GAAWuC,aACpB5B,QAAQK,GAAKoB,YAGbF,IAAAA,MAAAA,CAAiBG,KACZ,EACL5B,SAAST,GAAWwC,iBACpB7B,QAAQK,GAAKoB,YAHb,IAAA;ACnIOK,GAAAA,IAAiBC,CAAAA,OACN,YAAA,OAARA,MAAqBC,CAAAA,OAAOC,MAAMF,ECCrCG,GAAAA,IACXC,CAAAA,OAEOC,OAAOC,QAAoBF,EAAQG,EAAAA,IAAI,IAAIC,QAAWA,GAAMC,KAAAA;"}