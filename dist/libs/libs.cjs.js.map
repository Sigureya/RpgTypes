{"version":3,"file":"libs.cjs.js","sources":["../../src/libs/namedItemSource/format/core/detectErrors.ts","../../src/libs/namedItemSource/constants.ts","../../src/libs/templates/domainLabel/domainLabel.ts","../../src/libs/utils/isValidNumber.ts"],"sourcesContent":["import type {\r\n  FormatErrorLabels,\r\n  FormatLimits,\r\n  FormatErrorGroup,\r\n  FormatErrorItem,\r\n} from \"./formatErrorTypes\";\r\nimport type { FormatRule, FormatItemMapper } from \"./rule\";\r\nimport { getItemMappersFromRule, getPlaceHolderKeys } from \"./rule\";\r\nimport type { FormatInput, FormatWithSource } from \"./types\";\r\n\r\nexport const isValidFormatErrorGroup = (\r\n  formatError: FormatErrorGroup\r\n): boolean => {\r\n  return (\r\n    formatError.syntaxErrors.length === 0 &&\r\n    formatError.semanticErrors.length === 0\r\n  );\r\n};\r\n\r\nexport const collectFormatErrors = <T extends object>(\r\n  formatList: ReadonlyArray<FormatInput>,\r\n  formatRule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels,\r\n  limits: FormatLimits = {\r\n    placeHolderMaxLength: 50,\r\n    formatMaxLength: 200,\r\n  }\r\n): FormatErrorGroup[] => {\r\n  return formatList.reduce<FormatErrorGroup[]>((acc, format) => {\r\n    const errors = detectFormatErrors(format, formatRule, errorTexts, limits);\r\n    if (!isValidFormatErrorGroup(errors)) {\r\n      acc.push(errors);\r\n    }\r\n    return acc;\r\n  }, []);\r\n};\r\n\r\nexport const detectFormatErrors = <T extends object>(\r\n  format: FormatInput,\r\n  formatRule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels,\r\n  limits: FormatLimits = {\r\n    placeHolderMaxLength: 50,\r\n    formatMaxLength: 200,\r\n  }\r\n): FormatErrorGroup => {\r\n  if (format.pattern.length >= limits.formatMaxLength) {\r\n    return {\r\n      formatLabel: format.label,\r\n      syntaxErrors: [\r\n        {\r\n          message: errorTexts.formatVeryLong,\r\n          reason: format.pattern.slice(0, limits.formatMaxLength),\r\n        },\r\n      ],\r\n      semanticErrors: [],\r\n    };\r\n  }\r\n  return {\r\n    formatLabel: format.label,\r\n    semanticErrors: detectItemMapperErrors(format, formatRule, errorTexts),\r\n    syntaxErrors: detectInvalidPlaceholders(\r\n      format.pattern,\r\n      formatRule,\r\n      errorTexts,\r\n      limits.placeHolderMaxLength\r\n    ),\r\n  };\r\n};\r\n\r\nconst detectInvalidPlaceholders = <T extends object>(\r\n  format: string,\r\n  rule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels,\r\n  placeHolderMaxLength: number\r\n): FormatErrorItem[] => {\r\n  const matched = Array.from(format.matchAll(/\\{([.a-zA-Z0-9]+)\\}/g));\r\n  const placeHolderKeys: ReadonlySet<string> = getPlaceHolderKeys(rule);\r\n  return matched.reduce<FormatErrorItem[]>((acc, item) => {\r\n    const text: string = item[1];\r\n\r\n    if (text.length === 0) {\r\n      return acc;\r\n    }\r\n    if (text.length > placeHolderMaxLength) {\r\n      acc.push({\r\n        message: errorTexts.longPlaceHolder,\r\n        reason: text.slice(0, placeHolderMaxLength),\r\n      });\r\n      return acc;\r\n    }\r\n    if (!placeHolderKeys.has(text)) {\r\n      acc.push({\r\n        message: errorTexts.extraPlaceHolder,\r\n        reason: text,\r\n      });\r\n    }\r\n    return acc;\r\n  }, []);\r\n};\r\n\r\nconst detectItemMapperErrors = <T extends object>(\r\n  format: FormatWithSource,\r\n  formatRule: FormatRule<T>,\r\n  errorTexts: FormatErrorLabels\r\n): FormatErrorItem[] => {\r\n  return getItemMappersFromRule(formatRule).reduce<FormatErrorItem[]>(\r\n    (rule, item) => {\r\n      const error = checkItemMapperSourceError(format, item, errorTexts);\r\n      if (error) {\r\n        rule.push(error);\r\n      }\r\n      return rule;\r\n    },\r\n    []\r\n  );\r\n};\r\n\r\nconst checkItemMapperSourceError = <T>(\r\n  format: FormatWithSource,\r\n  rule: FormatItemMapper<T>,\r\n  errorTexts: FormatErrorLabels\r\n): FormatErrorItem | undefined => {\r\n  const includedName: boolean = format.pattern.includes(rule.placeHolder);\r\n  const hasSource: boolean = !!format.dataSource;\r\n  if (!includedName && hasSource) {\r\n    return {\r\n      message: errorTexts.missingName,\r\n      reason: rule.placeHolder,\r\n    };\r\n  }\r\n  if (includedName && !hasSource) {\r\n    return {\r\n      message: errorTexts.missingSourceId,\r\n      reason: rule.placeHolder,\r\n    };\r\n  }\r\n  return undefined;\r\n};\r\n","export const AUTHOR_RMMZ = \"rmmz\" as const;\r\nexport const SRC_COLOR = \"colors\" as const;\r\n","import type { DomainName } from \"./types\";\r\n\r\nexport const domainNames = <T extends Record<string, DomainName>>(\r\n  record: T\r\n): string[] => {\r\n  return Object.entries<DomainName>(record).map(([, value]) => value.title);\r\n};\r\n","export const isValidNumber = (val: unknown): val is number => {\r\n  return typeof val === \"number\" && !Number.isNaN(val);\r\n};\r\n"],"names":["detectInvalidPlaceholders","format","rule","errorTexts","placeHolderMaxLength","matched","Array","from","matchAll","placeHolderKeys","getPlaceHolderKeys","reduce","acc","item","text","length","push","message","longPlaceHolder","reason","slice","has","extraPlaceHolder","detectItemMapperErrors","formatRule","getItemMappersFromRule","error","checkItemMapperSourceError","includedName","pattern","includes","placeHolder","hasSource","dataSource","missingName","missingSourceId","limits","formatMaxLength","formatLabel","label","syntaxErrors","formatVeryLong","semanticErrors","record","Object","entries","map","value","title","val","Number","isNaN"],"mappings":";;8FAsEMA,IAA4B,CAChCC,IACAC,IACAC,IACAC,OAAAA;AAEA,QAAMC,IAAUC,MAAMC,KAAKN,GAAOO,SAAS,sBAAA,CAAA,GACrCC,IAAuCC,qBAAmBR,EAAAA;AAChE,SAAOG,EAAQM,OAA0B,CAACC,IAAKC,OAAAA;AACvC,UAAAC,KAAeD,GAAK,CAAA;AAEtB,WAAgB,MAAhBC,GAAKC,SACAH,KAELE,GAAKC,SAASX,MAChBQ,GAAII,KAAK;AAAA,MACPC,SAASd,GAAWe;AAAAA,MACpBC,QAAQL,GAAKM,MAAM,GAAGhB,EAEjBQ;AAAAA,IAAAA,CAAAA,GAAAA,OAEJH,EAAgBY,IAAIP,EACvBF,KAAAA,GAAII,KAAK,EACPC,SAASd,GAAWmB,kBACpBH,QAAQL,GAAAA,CAAAA,GAGLF;AAAAA,EACN,GAAA,CAAA,CAAA;AAAA,GAGCW,IAAyB,CAC7BtB,IACAuB,IACArB,OAEOsB,EAAAA,uBAAuBD,EAAYb,EAAAA,OACxC,CAACT,IAAMW,OAAAA;AACL,QAAMa,IAAQC,EAA2B1B,IAAQY,IAAMV,EAAAA;AAIhD,SAHHuB,KACFxB,GAAKc,KAAKU,CAAAA,GAELxB;GAET,CAIEyB,CAAAA,GAAAA,IAA6B,CACjC1B,IACAC,IACAC;AAEA,QAAMyB,KAAwB3B,GAAO4B,QAAQC,SAAS5B,GAAK6B,WAAAA,GACrDC,KAAuB/B,CAAAA,CAAAA,GAAOgC;AAChC,SAACL,CAAAA,MAAgBI,KACZ,EACLf,SAASd,GAAW+B,aACpBf,QAAQjB,GAAK6B,YAAAA,IAGbH,OAAiBI,KACZ;AAAA,IACLf,SAASd,GAAWgC;AAAAA,IACpBhB,QAAQjB,GAAK6B;AAAAA,EAHb,IAAA;AAAA;wNCnIqB,4BACF,uCDoCS,CAChC9B,IACAuB,IACArB,IACAiC,IAAuB,EACrBhC,sBAAsB,IACtBiC,iBAAiB,UAGfpC,GAAO4B,QAAQd,UAAUqB,EAAOC,kBAC3B,EACLC,aAAarC,GAAOsC,OACpBC,cAAc,CACZ;AAAA,EACEvB,SAASd,GAAWsC;AAAAA,EACpBtB,QAAQlB,GAAO4B,QAAQT,MAAM,GAAGgB,EAAOC,eAAAA;AAAAA,CAAAA,GAG3CK,gBAAgB,CAAA,EAAA,IAGb;AAAA,EACLJ,aAAarC,GAAOsC;AAAAA,EACpBG,gBAAgBnB,EAAuBtB,IAAQuB,IAAYrB,EAAAA;AAAAA,EAC3DqC,cAAcxC,EACZC,GAAO4B,SACPL,IACArB,IACAiC,EAAOhC;yBE9DXuC,CAAAA,OAEOC,OAAOC,QAAoBF,IAAQG,IAAI,CAAA,GAAIC,EAAAA,MAAWA,GAAMC,KAAAA,2BCLvCC,CAAAA,OACN,YAAA,OAARA,MAAqBC,CAAAA,OAAOC,MAAMF,EAAAA;"}