"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const _=require("../shared/lookup.cjs.js"),I=(r,e)=>Object.entries(e).reduce((n,[t,c])=>{if(t in r){const s=r[t];if(typeof s=="string")return{...n,[t]:c(s)}}return n},{}),l=(r,e,n,t)=>({default:e,...I(n,t),kind:r}),P=(r,e,n)=>({default:[],...I(e,n),kind:r}),M="help",A="kind",x="text",E="struct",z=r=>{const e=JSON.parse(r);return Array.isArray(e)?e.map(h):typeof e=="object"&&e!==null?Object.fromEntries(Object.entries(e).map(([n,t])=>[n,h(t)])):e},h=r=>{if(typeof r!="string")return r;try{const e=JSON.parse(r);return Array.isArray(e)?e.map(h):typeof e=="object"&&e!==null?Object.fromEntries(Object.entries(e).map(([n,t])=>[n,h(t)])):e}catch{return r}},K=r=>{if(A in r.attr){const e=U[r.attr.kind];if(e)return e(r)}return l("any","",r.attr,C)},a=r=>r,W=r=>r.replace("[","").replace("]","").split(",").map(e=>parseFloat(e.replaceAll('"',"").trim())).filter(e=>!isNaN(e)),C={default:a,text:a,desc:a,parent:a},L=r=>l("string","",r.attr,C),F=r=>{const e={default:n=>z(n),text:a,desc:a,parent:a};return P("string[]",r.attr,e)},o=(r,e)=>{const n={default:W,text:a,desc:a,parent:a};return P(e,r.attr,n)},m=(r,e)=>{const n={default:t=>parseInt(t,10),text:a,desc:a,parent:a};return l(e,0,r.attr,n)},U={number:r=>(e=>{const n={default:t=>parseFloat(t),text:a,desc:a,decimals:t=>parseInt(t,10),min:t=>parseFloat(t),max:t=>parseFloat(t),parent:a};return l("number",0,e.attr,n)})(r),"number[]":r=>{const e={default:W,text:a,desc:a,decimals:n=>parseInt(n,10),min:n=>parseFloat(n),max:n=>parseFloat(n),parent:a};return P("number[]",r.attr,e)},string:L,"string[]":F,multiline_string:L,"multiline_string[]":F,combo:r=>{var n;const e=((n=r.options)==null?void 0:n.map(t=>t.option))??[];return{...l("combo","",r.attr,C),options:e}},select:r=>{var n;const e=((n=r.options)==null?void 0:n.map(t=>({option:t.option,value:t.value})))??[];return{...l("select","",r.attr,C),options:e}},actor:r=>m(r,"actor"),"actor[]":r=>o(r,"actor[]"),class:r=>m(r,"class"),"class[]":r=>o(r,"class[]"),skill:r=>m(r,"skill"),"skill[]":r=>o(r,"skill[]"),item:r=>m(r,"item"),"item[]":r=>o(r,"item[]"),weapon:r=>m(r,"weapon"),"weapon[]":r=>o(r,"weapon[]"),armor:r=>m(r,"armor"),"armor[]":r=>o(r,"armor[]"),state:r=>m(r,"state"),"state[]":r=>o(r,"state[]"),enemy:r=>m(r,"enemy"),"enemy[]":r=>o(r,"enemy[]"),common_event:r=>m(r,"common_event"),"common_event[]":r=>o(r,"common_event[]"),switch:r=>m(r,"switch"),"switch[]":r=>o(r,"switch[]"),variable:r=>m(r,"variable"),"variable[]":r=>o(r,"variable[]"),troop:r=>m(r,"troop"),"troop[]":r=>o(r,"troop[]"),boolean:r=>{const e={default:n=>n==="true",text:a,desc:a,on:a,off:a,parent:a};return l("boolean",!0,r.attr,e)},file:r=>{const e={default:a,text:a,desc:a,parent:a,dir:a};return{dir:"",...l("file","",r.attr,e)}},"file[]":r=>{const e={default:n=>z(n),text:a,desc:a,parent:a,dir:a};return{dir:"",...P("file[]",r.attr,e)}}},v=r=>r.kind.endsWith("[]"),N=r=>r.kind==="struct",T=r=>r.kind==="struct[]",V=["string","multiline_string","select"],J=(r,e,n)=>{const t=e.get(r);return t?t.filter(c=>((s,u)=>!(!N(s)&&!T(s)||!s.struct||u.has(s.struct)))(c,n)).flatMap(c=>{const s=c.struct;return n.add(s),[s,...J(s,e,n)]}):[]},R="BODY",Z="STRUCT",y="NONE",Y=(r,e)=>{const n=r.lines.length>0?S(r):r,t=e[1]||void 0;return{...n,structName:t,blockType:t?Z:"INVALID",locale:e[2],lines:[]}},$=r=>({...r.lines.length>0?S(r):r,blockType:R,structName:void 0,locale:void 0,lines:[]}),S=r=>r.blockType===R?{...r,bodies:r.bodies.concat([{lines:[...r.lines]}]),lines:[],blockType:y}:r.structName&&r.blockType===Z?{...r,structs:r.structs.concat([{struct:r.structName,locale:r.locale,lines:[...r.lines]}]),blockType:y,structName:void 0,locale:void 0,lines:[]}:{...r,blockType:y,structName:void 0,lines:[]},G=r=>r.currentOption?{items:r.items.concat({option:r.currentOption,value:r.currentOption})}:r,j=r=>({...typeof r.desc=="string"?{desc:r.desc}:{},...typeof r.text=="string"?{text:r.text}:{}}),O=r=>{const e=Q(r),n=rr(e);return X(n)},Q=r=>{if(r.currentParam&&r.currentOption){const e=r.currentParam.attr.kind;if(e==="select"||e==="combo")return{...r,currentParam:{...r.currentParam,options:G(r.currentOption).items}}}return r},X=r=>r.currentParam?{...r,params:[...r.params,r.currentParam],currentParam:null,currentContext:null}:r,rr=r=>{if(!r.currentCommand)return r;const e=r.currentParam?[...r.currentCommand.args,r.currentParam]:r.currentCommand.args,n={...j(r.currentCommand),command:r.currentCommand.command,args:e};return{...r,commands:[...r.commands,n],currentCommand:null,currentParam:null,currentContext:null,currentOption:null}},D=(r,e)=>{const n=r.lines.reduce((t,c)=>{const s=c.trim().replace(/^\*\s?/,"");if(!s.startsWith("@"))return t.currentContext===M?{...t,helpLines:t.helpLines.concat(s)}:t;const[u,...p]=s.slice(1).split(" "),f=p.join(" ").trim(),b=e[u];return b?b(t,f):t},nr());return O(n)},er=(r,e)=>{const n=(u=>{const p=u.split(`
`),f={structs:[],bodies:[],structName:void 0,locale:void 0,lines:[],blockType:y},b=p.reduce((d,H)=>{const g=H.trim(),B=g.match(/^\/\*~struct~([A-Za-z0-9_]+)(?::([A-Za-z0-9_-]+))?/);return B?Y(d,B):g==="/*:"?$(d):g==="*/"?d.lines.length>0?S(d):d:{...d,lines:d.lines.concat([g])}},f);return{structs:b.structs,bodies:b.bodies}})(r),t=n.structs.map(u=>(p=>{const f=D(p,q);return{name:p.struct,params:f.params}})(u)),c=(u=>{if(u.bodies.length!==0)return u.bodies[0]})(n);if(!c)return{params:[],commands:[],meta:{},helpLines:[],structs:t};const s=D(c,e);return{params:s.params,commands:s.commands,meta:s.meta,helpLines:s.helpLines,structs:t}},nr=()=>({helpLines:[],params:[],commands:[],currentParam:null,currentCommand:null,currentContext:null,currentOption:null,dependencies:{base:[],orderBefore:[],orderAfter:[]},meta:{}}),i=(r,e,n)=>r.currentParam&&!(e in r.currentParam.attr)?{...r,currentParam:{...r.currentParam,attr:{...r.currentParam.attr,[e]:n}}}:r,k=(r,e,n)=>({...r,meta:{[e]:n,...r.meta}}),q={param:(r,e)=>{const n=O(r);return n.params.some(t=>t.name===e)?n:{...n,currentContext:"param",currentParam:{name:e,attr:{}}}},text:(r,e)=>r.currentParam?i(r,x,e):r.currentCommand&&!(x in r.currentCommand)?{...r,currentCommand:{...j(r.currentCommand),command:r.currentCommand.command,args:r.currentCommand.args,[x]:e}}:r,desc:(r,e)=>r.currentParam?i(r,"desc",e):r.currentCommand?{...r,currentCommand:{...r.currentCommand,desc:e}}:r,command:(r,e)=>{const n=O(r);return n.commands.some(t=>t.command===e)?n:{...n,currentCommand:{command:e,args:[]},currentParam:null}},arg:(r,e)=>{if(!r.currentCommand)return r;if(r.currentParam){const n={...j(r.currentCommand),command:r.currentCommand.command,args:r.currentCommand.args.concat(r.currentParam)};return{...r,commands:r.commands,currentCommand:n,currentContext:"arg",currentParam:{name:e,attr:{}}}}return{...r,currentParam:{name:e,attr:{}}}},help:r=>({...O(r),currentContext:M}),option:(r,e)=>{if(!r.currentParam)return r;const n=((t,c)=>t.currentOption?{items:t.items.concat({option:t.currentOption,value:t.currentOption}),currentOption:c}:{items:t.items,currentOption:c})(r.currentOption??{items:[]},e);return{...r,currentOption:n}},value:(r,e)=>{if(!r.currentOption)return r;const n=((t,c)=>t.currentOption?{items:t.items.concat({option:t.currentOption,value:c})}:{items:t.items})(r.currentOption,e);return{...r,currentOption:n}},type:(r,e)=>{if((n=>n.endsWith(">")&&n.startsWith("struct<"))(e)){const n=e.slice(7,-1),t=i(r,E,n);return i(t,A,E)}return r.currentParam?i(r,A,e):r},default:(r,e)=>i(r,"default",e),on:(r,e)=>i(r,"on",e),off:(r,e)=>i(r,"off",e),min:(r,e)=>i(r,"min",e),max:(r,e)=>i(r,"max",e),base:(r,e)=>{return{...r,dependencies:(n=r.dependencies,t=e,{orderAfter:n.orderAfter,orderBefore:n.orderBefore,base:n.base.concat(t)})};var n,t},orderAfter:(r,e)=>{return{...r,dependencies:(n=r.dependencies,t=e,{base:n.base,orderBefore:n.orderBefore,orderAfter:n.orderAfter.concat(t)})};var n,t},orderBefore:(r,e)=>{return{...r,dependencies:(n=r.dependencies,t=e,{base:n.base,orderAfter:n.orderAfter,orderBefore:n.orderBefore.concat(t)})};var n,t},author:(r,e)=>k(r,"author",e),plugindesc:(r,e)=>k(r,"plugindesc",e),url:(r,e)=>k(r,"url",e)},tr=r=>ar((e=>er(e,q))(r)),ar=r=>({target:"MZ",meta:r.meta,commands:sr(r.commands),params:w(r.params),structs:cr(r.structs)}),w=r=>Object.fromEntries(r.map(e=>[e.name,K(e)])),sr=r=>Object.fromEntries(r.map(e=>[e.command,{desc:e.desc,text:e.text,args:w(e.args)}])),cr=r=>Object.fromEntries(r.map(e=>[e.name,{params:w(e.params)}]));exports.isRmmzDataKind=_.isRmmzDataKind,exports.lookupKind=_.lookupKind,exports.classifyPluginParams=r=>{const e=[],n=[],t=[],c=[];return r.params.forEach(s=>{N(s.attr)?e.push({name:s.name,attr:s.attr}):T(s.attr)?n.push({name:s.name,attr:s.attr}):v(s.attr)?c.push({name:s.name,attr:s.attr}):t.push({name:s.name,attr:s.attr})}),{structs:e,structArrays:n,scalas:t,scalaArrays:c}},exports.compileAttributes=K,exports.createStructMap=r=>new Map(r.map(e=>[e.struct,e.params.map(n=>n.attr)])),exports.isArrayParam=v,exports.isArrayParamEx=(r,e)=>!!v(r)&&r.kind===`${e}[]`,exports.isStructArrayParam=T,exports.isStructParam=N,exports.paramHasText=r=>V.includes(r.kind),exports.pluginSourceToJSON=r=>tr(r),exports.structDependencies=(r,e)=>J(r,e,new Set);
