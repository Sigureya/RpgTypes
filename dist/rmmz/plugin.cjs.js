"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const E=require("../shared/lookup.cjs.js"),g=r=>r.kind.endsWith("[]"),L=r=>!g(r)&&r.kind!=="struct",N=r=>r.kind==="struct",S=r=>r.kind==="struct[]",$=["string","multiline_string","select","combo","any"],P={string:{type:"string"},number:{type:"number"},boolean:{type:"boolean"},armor:{type:"number"},actor:{type:"number"},class:{type:"number"},enemy:{type:"number"},skill:{type:"number"},state:{type:"number"},item:{type:"number"},weapon:{type:"number"},common_event:{type:"number"},switch:{type:"number"},variable:{type:"number"},troop:{type:"number"},multiline_string:{type:"string"},file:{type:"string"},combo:{type:"string"},select:{type:"string"},any:{type:"string"},struct:{type:"struct"}},F=r=>P[r.kind].type==="number",K=(r,e)=>Object.entries(e).reduce((t,[n,c])=>{if(n in r){const s=r[n];if(typeof s=="string")return{...t,[n]:c(s)}}return t},{}),l=(r,e,t,n)=>({default:e,...K(t,n),kind:r}),k=(r,e,t)=>({default:[],...K(e,t),kind:r}),V="help",T="kind",v="text",D="struct",W=r=>{const e=JSON.parse(r);return Array.isArray(e)?e.map(x):typeof e=="object"&&e!==null?Object.fromEntries(Object.entries(e).map(([t,n])=>[t,x(n)])):e},x=r=>{if(typeof r!="string")return r;try{const e=JSON.parse(r);return Array.isArray(e)?e.map(x):typeof e=="object"&&e!==null?Object.fromEntries(Object.entries(e).map(([t,n])=>[t,x(n)])):e}catch{return r}},J=r=>{if(T in r.attr){const e=G[r.attr.kind];if(e)return e(r)}return l("any","",r.attr,C)},a=r=>r,R=r=>r.replace("[","").replace("]","").split(",").map(e=>parseFloat(e.replaceAll('"',"").trim())).filter(e=>!isNaN(e)),C={default:a,text:a,desc:a,parent:a},I=r=>l("string","",r.attr,C),M=r=>{const e={default:t=>W(t),text:a,desc:a,parent:a};return k("string[]",r.attr,e)},o=(r,e)=>{const t={default:R,text:a,desc:a,parent:a};return k(e,r.attr,t)},m=(r,e)=>{const t={default:n=>parseInt(n,10),text:a,desc:a,parent:a};return l(e,0,r.attr,t)},G={number:r=>(e=>{const t={default:n=>parseFloat(n),text:a,desc:a,decimals:n=>parseInt(n,10),min:n=>parseFloat(n),max:n=>parseFloat(n),parent:a};return l("number",0,e.attr,t)})(r),"number[]":r=>{const e={default:R,text:a,desc:a,decimals:t=>parseInt(t,10),min:t=>parseFloat(t),max:t=>parseFloat(t),parent:a};return k("number[]",r.attr,e)},string:I,"string[]":M,multiline_string:I,"multiline_string[]":M,combo:r=>{var t;const e=((t=r.options)==null?void 0:t.map(n=>n.option))??[];return{...l("combo","",r.attr,C),options:e}},select:r=>{var t;const e=((t=r.options)==null?void 0:t.map(n=>({option:n.option,value:n.value})))??[];return{...l("select","",r.attr,C),options:e}},actor:r=>m(r,"actor"),"actor[]":r=>o(r,"actor[]"),class:r=>m(r,"class"),"class[]":r=>o(r,"class[]"),skill:r=>m(r,"skill"),"skill[]":r=>o(r,"skill[]"),item:r=>m(r,"item"),"item[]":r=>o(r,"item[]"),weapon:r=>m(r,"weapon"),"weapon[]":r=>o(r,"weapon[]"),armor:r=>m(r,"armor"),"armor[]":r=>o(r,"armor[]"),state:r=>m(r,"state"),"state[]":r=>o(r,"state[]"),enemy:r=>m(r,"enemy"),"enemy[]":r=>o(r,"enemy[]"),common_event:r=>m(r,"common_event"),"common_event[]":r=>o(r,"common_event[]"),switch:r=>m(r,"switch"),"switch[]":r=>o(r,"switch[]"),variable:r=>m(r,"variable"),"variable[]":r=>o(r,"variable[]"),troop:r=>m(r,"troop"),"troop[]":r=>o(r,"troop[]"),boolean:r=>{const e={default:t=>t==="true",text:a,desc:a,on:a,off:a,parent:a};return l("boolean",!0,r.attr,e)},file:r=>{const e={default:a,text:a,desc:a,parent:a,dir:a};return{dir:"",...l("file","",r.attr,e)}},"file[]":r=>{const e={default:t=>W(t),text:a,desc:a,parent:a,dir:a};return{dir:"",...k("file[]",r.attr,e)}}},Z=(r,e,t)=>{const n=e.get(r);return n?n.filter(c=>((s,u)=>!(!N(s)&&!S(s)||!s.struct||u.has(s.struct)))(c,t)).flatMap(c=>{const s=c.struct;return t.add(s),[s,...Z(s,e,t)]}):[]},q="BODY",H="STRUCT",O="NONE",Q=(r,e)=>{const t=r.lines.length>0?w(r):r,n=e[1]||void 0;return{...t,structName:n,blockType:n?H:"INVALID",locale:e[2],lines:[]}},X=r=>({...r.lines.length>0?w(r):r,blockType:q,structName:void 0,locale:void 0,lines:[]}),w=r=>r.blockType===q?{...r,bodies:r.bodies.concat([{lines:[...r.lines]}]),lines:[],blockType:O}:r.structName&&r.blockType===H?{...r,structs:r.structs.concat([{struct:r.structName,locale:r.locale,lines:[...r.lines]}]),blockType:O,structName:void 0,locale:void 0,lines:[]}:{...r,blockType:O,structName:void 0,lines:[]},rr=r=>r.currentOption?{items:r.items.concat({option:r.currentOption,value:r.currentOption})}:r,j=r=>({...typeof r.desc=="string"?{desc:r.desc}:{},...typeof r.text=="string"?{text:r.text}:{}}),h=r=>{const e=er(r),t=nr(e);return tr(t)},er=r=>{if(r.currentParam&&r.currentOption){const e=r.currentParam.attr.kind;if(e==="select"||e==="combo")return{...r,currentParam:{...r.currentParam,options:rr(r.currentOption).items}}}return r},tr=r=>r.currentParam?{...r,params:[...r.params,r.currentParam],currentParam:null,currentContext:null}:r,nr=r=>{if(!r.currentCommand)return r;const e=r.currentParam?[...r.currentCommand.args,r.currentParam]:r.currentCommand.args,t={...j(r.currentCommand),command:r.currentCommand.command,args:e};return{...r,commands:[...r.commands,t],currentCommand:null,currentParam:null,currentContext:null,currentOption:null}},z=(r,e)=>{const t=r.lines.reduce((n,c)=>{const s=c.trim().replace(/^\*\s?/,"");if(!s.startsWith("@"))return n.currentContext===V?{...n,helpLines:n.helpLines.concat(s)}:n;const[u,...d]=s.slice(1).split(" "),b=d.join(" ").trim(),f=e[u];return f?f(n,b):n},sr());return h(t)},ar=(r,e)=>{const t=(u=>{const d=u.split(`
`),b={structs:[],bodies:[],structName:void 0,locale:void 0,lines:[],blockType:O},f=d.reduce((p,Y)=>{const y=Y.trim(),B=y.match(/^\/\*~struct~([A-Za-z0-9_]+)(?::([A-Za-z0-9_-]+))?/);return B?Q(p,B):y==="/*:"?X(p):y==="*/"?p.lines.length>0?w(p):p:{...p,lines:p.lines.concat([y])}},b);return{structs:f.structs,bodies:f.bodies}})(r),n=t.structs.map(u=>(d=>{const b=z(d,U);return{name:d.struct,params:b.params}})(u)),c=(u=>{if(u.bodies.length!==0)return u.bodies[0]})(t);if(!c)return{params:[],commands:[],meta:{},helpLines:[],structs:n};const s=z(c,e);return{params:s.params,commands:s.commands,meta:s.meta,helpLines:s.helpLines,structs:n}},sr=()=>({helpLines:[],params:[],commands:[],currentParam:null,currentCommand:null,currentContext:null,currentOption:null,dependencies:{base:[],orderBefore:[],orderAfter:[]},meta:{}}),i=(r,e,t)=>r.currentParam&&!(e in r.currentParam.attr)?{...r,currentParam:{...r.currentParam,attr:{...r.currentParam.attr,[e]:t}}}:r,A=(r,e,t)=>({...r,meta:{[e]:t,...r.meta}}),U={param:(r,e)=>{const t=h(r);return t.params.some(n=>n.name===e)?t:{...t,currentContext:"param",currentParam:{name:e,attr:{}}}},text:(r,e)=>r.currentParam?i(r,v,e):r.currentCommand&&!(v in r.currentCommand)?{...r,currentCommand:{...j(r.currentCommand),command:r.currentCommand.command,args:r.currentCommand.args,[v]:e}}:r,desc:(r,e)=>r.currentParam?i(r,"desc",e):r.currentCommand?{...r,currentCommand:{...r.currentCommand,desc:e}}:r,command:(r,e)=>{const t=h(r);return t.commands.some(n=>n.command===e)?t:{...t,currentCommand:{command:e,args:[]},currentParam:null}},arg:(r,e)=>{if(!r.currentCommand)return r;if(r.currentParam){const t={...j(r.currentCommand),command:r.currentCommand.command,args:r.currentCommand.args.concat(r.currentParam)};return{...r,commands:r.commands,currentCommand:t,currentContext:"arg",currentParam:{name:e,attr:{}}}}return{...r,currentParam:{name:e,attr:{}}}},help:r=>({...h(r),currentContext:V}),option:(r,e)=>{if(!r.currentParam)return r;const t=((n,c)=>n.currentOption?{items:n.items.concat({option:n.currentOption,value:n.currentOption}),currentOption:c}:{items:n.items,currentOption:c})(r.currentOption??{items:[]},e);return{...r,currentOption:t}},value:(r,e)=>{if(!r.currentOption)return r;const t=((n,c)=>n.currentOption?{items:n.items.concat({option:n.currentOption,value:c})}:{items:n.items})(r.currentOption,e);return{...r,currentOption:t}},type:(r,e)=>{if((t=>t.endsWith(">")&&t.startsWith("struct<"))(e)){const t=e.slice(7,-1),n=i(r,D,t);return i(n,T,D)}return r.currentParam?i(r,T,e):r},default:(r,e)=>i(r,"default",e),on:(r,e)=>i(r,"on",e),off:(r,e)=>i(r,"off",e),min:(r,e)=>i(r,"min",e),max:(r,e)=>i(r,"max",e),base:(r,e)=>{return{...r,dependencies:(t=r.dependencies,n=e,{orderAfter:t.orderAfter,orderBefore:t.orderBefore,base:t.base.concat(n)})};var t,n},orderAfter:(r,e)=>{return{...r,dependencies:(t=r.dependencies,n=e,{base:t.base,orderBefore:t.orderBefore,orderAfter:t.orderAfter.concat(n)})};var t,n},orderBefore:(r,e)=>{return{...r,dependencies:(t=r.dependencies,n=e,{base:t.base,orderAfter:t.orderAfter,orderBefore:t.orderBefore.concat(n)})};var t,n},author:(r,e)=>A(r,"author",e),plugindesc:(r,e)=>A(r,"plugindesc",e),url:(r,e)=>A(r,"url",e)},cr=r=>or((e=>ar(e,U))(r)),or=r=>({target:"MZ",meta:r.meta,commands:mr(r.commands),params:_(r.params),structs:ur(r.structs)}),_=r=>Object.fromEntries(r.map(e=>[e.name,J(e)])),mr=r=>Object.fromEntries(r.map(e=>[e.command,{desc:e.desc,text:e.text,args:_(e.args)}])),ur=r=>Object.fromEntries(r.map(e=>[e.name,{params:_(e.params)}]));exports.isRmmzDataKind=E.isRmmzDataKind,exports.lookupKind=E.lookupKind,exports.classifyPluginParams=r=>{const e=[],t=[],n=[],c=[];return r.params.forEach(s=>{N(s.attr)?e.push({name:s.name,attr:s.attr}):S(s.attr)?t.push({name:s.name,attr:s.attr}):g(s.attr)?c.push({name:s.name,attr:s.attr}):n.push({name:s.name,attr:s.attr})}),{structs:e,structArrays:t,scalas:n,scalaArrays:c}},exports.compileAttributes=J,exports.createStructMap=r=>new Map(r.map(e=>[e.struct,e.params.map(t=>t.attr)])),exports.isArrayParam=g,exports.isArrayParamEx=(r,e)=>!!g(r)&&r.kind===`${e}[]`,exports.isNumberArrayParam=r=>P[r.kind.replace("[]","")].type==="number",exports.isNumberValueParam=r=>L(r)&&F(r),exports.isNumberValueParamEx=F,exports.isScalarParam=L,exports.isStringArrayParam=r=>P[r.kind.replace("[]","")].type==="string",exports.isStringValueParam=r=>P[r.kind].type==="string",exports.isStructArrayParam=S,exports.isStructParam=N,exports.paramHasText=r=>$.includes(r.kind),exports.pluginSourceToJSON=r=>cr(r),exports.structDependencies=(r,e)=>Z(r,e,new Set);
